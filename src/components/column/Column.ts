import { Creator, Newable, RootElementConnector } from "../../common/common.types";
import LeaderboardHeader from "../headers/Header";
import Header from "../headers/Header";
import ElementCreator from "../../factories/ElementCreator";
import Row from "../row/Row";
import Logger from "../../common/Logger/Logger";
import ElementController from "../../common/ElementController";
import { SEMANTIC_TAGS } from "../style/common.enum";

export interface LeaderboardData {
   /*
    * @type {header} is generated by default by leaderboard
    */
   header: string;

   /*
    * @type {content} will be used for generic leaderboards
    */
   content: string | string[];
   place: number;
   points: number;
}

type RowProperties = {
   place?: number;
   points?: number;
} & unknown;

interface ColumnProperties extends RowProperties {
   header: string;
   rows: unknown[];
}

type RawColumnProperties = any;

enum COLUMN_DATA_LOGS {
   NO_DATA_FOUND = "Cannot find header and row data."
}
class Column implements RootElementConnector, Creator {
   root: HTMLElement;
   _elementCreator: ElementCreator;
   private _logger: Logger;

   constructor(root: HTMLElement, private _lbData: any) {
      this.root = root;
      this._elementCreator = new ElementCreator();
      this._logger = new Logger(this as unknown as Newable);
   }

   public render(): HTMLElement[] {
      return this._createColumns();
   }

   private _createColumns() {
      const columnsData = this._lbData.reduce(
         (
            headersAccumulator: ColumnProperties[],
            preParsedElement: RawColumnProperties
         ) => {
            if (!preParsedElement) {
               this._logger.log(COLUMN_DATA_LOGS.NO_DATA_FOUND);
               return;
            }

            const preParsedHeaders = Object.keys(preParsedElement);
            if (!preParsedHeaders) return;

            preParsedHeaders.forEach((header) => {
               if (preParsedElement.hasOwnProperty(header)) {
                  const singleRowForHeader: RowProperties = preParsedElement[header];
                  const isHeaderAlreadyExistsInAcc: boolean = headersAccumulator.some(
                     (el: { header: string }) => el.header === header
                  );

                  /**
                   * @const isHeaderAlreadyExistsInAcc if header already exists in array of accumulator
                   */
                  if (isHeaderAlreadyExistsInAcc) {
                     return this._appendNewRowToExistingHeader(
                        headersAccumulator,
                        header,
                        singleRowForHeader
                     );
                  } else {
                     headersAccumulator.push({ header, rows: [singleRowForHeader] });
                  }
               }
            });
            return headersAccumulator;
         },
         []
      );
      console.log({ columnsData });

      return this._generateColumns(columnsData);
   }

   private _generateColumns(columnsData: ColumnProperties[]) {
      return columnsData.map(({ rows, header }: ColumnProperties) => {
         const columnContainer = this._elementCreator.container().getElement;
         const columnHeaderElement = this._generateColumnHeader(header);
         const columnsRows = rows.map(
            (rowData: unknown): HTMLElement => this._generateRowElement(rowData)
         );

         this._appendHeaderToColumnContainer(columnContainer, columnHeaderElement);
         this._appendElementsToColumnContainer(columnsRows, columnContainer);
         return columnContainer;
      });
   }

   private _appendHeaderToColumnContainer(
      columnContainer: HTMLElement,
      columnHeaderElement: HTMLElement
   ): void {
      ElementController.appendElementsToContainer(columnContainer, columnHeaderElement);
   }

   private _appendElementsToColumnContainer(
      columnsRows: HTMLElement[],
      columnContainer: HTMLElement
   ): void {
      columnsRows.forEach((rowElement: HTMLElement) =>
         ElementController.appendElementsToContainer(columnContainer, rowElement)
      );
   }

   private _generateColumnHeader(headerText: string) {
      return this._elementCreator.createText(SEMANTIC_TAGS.PRIMARY_TEXT, headerText)
         .getElement;
   }

   private _generateRowElement(rowData: unknown) {
      const instanceOfRow = new Row(this.root, rowData);
      return instanceOfRow.render();
   }

   private _appendNewRowToExistingHeader(
      array: ColumnProperties[],
      iterator: string,
      rowsToAppend: RowProperties
   ) {
      const headerIndexInAcc = array.findIndex((el: { [x: string]: any }) => {
         return el.header === iterator;
      });
      const existingHeaderInAcc = array[headerIndexInAcc];
      return existingHeaderInAcc.rows.push(rowsToAppend);
   }

   private _instantiateHeader(txt: string): Header {
      return new LeaderboardHeader(this.root, txt);
   }

   private _instantiateRow(): Row {
      return new Row(this.root, this._lbData);
   }
}

export default Column;
